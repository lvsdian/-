[TOC]

## 并发基础

### 线程基本概念

#### 创建线程

- 线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。在`java`中创建线程方式：继承`Thread`类；实现`Runnable`接口。

#### 线程基本属性和方法

- 状态

1. `new`：没有调用`start`的线程状态
2. `terminated`：线程运行结束后的状态
3. `runnable`：调用`start`后在执行`run`方法且没有阻塞时的状态
4. `blocked`：线程在等待锁
5. `waiting`：等待某个条件
6. `timed_waiting`：超时

- daemon

  守护线程，为其他线程提供服务，不是不可或缺，被守护线程结束时，守护线程也会退出。

  注意：

  - `setDaemon(true)`必须在`start()`前设置，不能把正在运行的常规线程设置为守护线程。
  - 守护线程永远不会访问固定资源，比如文件、数据库，因为它虽说可能退出。

- sleep方法

  让当前线程睡眠指定时间，不会释放锁，会让出CPU进入**阻塞态**，**任何优先级线程**都能得到执行机会。如果被中断，会抛出`InterruptedException`。

- yield方法

  只能让**拥有相同优先级的线程**获取CPU的机会，不会释放锁，会让出CPU，进入**就绪态**，只需等待重新获取CPU执行时间。

- join

  `join`方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。在A线程中调用了B线程的`join()`方法时，表示只有当B线程执行完毕时，A线程才能继续执行。

#### 共享内存及可能存在的问题

##### 竞态条件

线程的执行时序影响结果。

##### 内存可见性

在计算机系统中，数据可以写到内存、缓存、CPU寄存器，访问一个变量时，可能直接从缓存或寄存器中取，而不一定从内存取，修改一个变量时，也可能先写到缓存，稍后才会同步更新到内存中。多线程环境下，一个线程对内存的修改，可能没及时同步到内存，别的线程也可能没从内存读，所以导致别的线程看不到它的修改。

解决方案：`volatile`；`synchronized`；显式锁

##### 线程优点

- 充分利用多CPU的计算能力及硬件资源
- 用户界面程序或服务器应用程序中可以提升用户体验
- 创建、调度、切换需要消耗资源

### synchronized

synchronized可修饰实例方法、静态方法、代码块

#### 修饰实例方法

```java
public class Counter extends Thread{
    private int count;
    //加了synchronized后，方法内的代码就变成了原子操作。
    public synchronized void incr(){
        count ++;
    }
    public synchronized int getCount(){
        return count;
    }
}
```

此时，synchronized保护的是**当前实例对象，即this，多个线程可以同时执行同一个synchronized实例方法，只要它们访问的对象不同即可**。比如：

```java
Counter counter1 = new Counter();
Counter counter2 = new Counter();
Thread t1 = new CounterThread(counter1);
Thread t2 = new CounterThread(counter2);
t1.start();
t2.start();
```

对于同一个`counter`对象，一个线程执行`incr()`方法，另一个线程执行`getCount()`方法，它们是不能同时执行的。

this对象有一个锁和一个等待队列，锁只能被一个线程持有，线程执行synchronized实例方法时，尝试获得锁，如果获得，继续下一步；如果不能获得，加入等待队列，阻塞并等待唤醒。

#### 修饰静态方法

```java
public class Counter {
    private static int count = 0;
    public static synchronized void incr(){
        count ++;
    }
    public static synchronized int getCount(){
        return count;
    }
}
```

此时，synchronized保护的是**类对象，即`Counter.class`，synchronized实例方法和synchronized静态方法保护的是不同对象，不同两个线程可以一个执行synchronized静态方法，另一个执行synchronized实例方法。**

#### 修饰代码块

如下：等价于上面的修饰实例方法

```java
public class Counter {
    private int count = 0;
    public void incr(){
        synchronized (this){
            count ++;
        }
    }
    public int getCount(){
        synchronized(this){
            return count;
        }
    }
}

```



如下：等价于上面的修饰静态方法

```java
public class Counter {
    private static int count;
    public static void incr(){
        synchronized (Counter.class){
            count ++;
        }
    }
    public static int getCount(){
        synchronized(Counter.class){
            return count;
        }
    }
}

```

synchronized几个特性

- 可重入性

  synchronized是可重入的，即**对同一个执行线程，它在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用**。比如在一个synchronized实例方法内，可以直接调用其他synchronized实例方法。

  可重入是通过**记录锁的持有线程和持有数量来实现的**，当调用被synchronized保护的代码时，检查对象是否已经被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。

- 内存可见性

  **synchronized除了保证原子操作外，还可以保证内存可见性，在释放锁时，所有写入都会写回内存，获得锁后，都会从内存中读最新数据。**

- 死锁

  线程a持有锁A，等待锁B；线程b持有锁B,等待锁A。a、b陷入互相等待，谁都执行不下去。

  解决方案：改用显式锁或使用死锁检测工具`jstack`等

##### wait/notify

​		除了用于锁的等待队列，每个对象还有一个条件队列，用于线程间的协作。`wait`会把当前线程放到条件队列上并阻塞，它需要等待一个条件，这个条件需要其他线程改变；`notify`就是从条件队列中选一个线程，将其从队列中移除并唤醒。`wait`执行过程：

1. 当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为`waiting`或`timed_waiting`
2. 等待时间到或被其他线程调用`notify/notifyAll`从条件队列移除，这是重新竞争对象锁：
   1. 如果能够获得对象锁：线程转态变为`runnable`，并从`wait`调用中返回。
   2. 否则，进入对象锁的等待队列，线程状态变为`blocked`，获得锁后才会从`wait`调用中返回。

### 中断

​		停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。	

​		`Thread`类中定义的中断方法：

- `isInterrupted`：返回对应线程中断标志位是否为`true`。
- `interrupted`：返回对应线程中断标志位是否为`true`，并清空中断标志位(即如果连续两次调用，第1次为`true`，第2次就为`false`，除非同时又发生一次中断)。
- `interrupt`：中断对应线程。

## 并发包基础

### 原子变量和CAS

原子变量：包含一些以原子方式实现组合操作的方法。比如[AtomicInteger](AtomicInteger.md)

CAS：`public final boolean compareAndSet(int expect,int update)`方法的简称。如果当前值等于`expect`，就更新为`update`,否则不更新。

cas缺点：

1. 多次检测，如果一直有冲突，则开销很大。
2. 对多个共享变量操作时，无法保证操作的原子性。
3. ABA问题。比如内存地址V初次读取的值为A,准备赋值时，检查它的值仍为A,但在这段时间内，它的值可能发生过变化。java并发包提供`AtomicStampedReference`类解决这个问题。在修改值的同时附加一个时间戳，只有值和时间戳都相同才进行修改。

### 显式锁

`java.util.concurrent.locks.Lock`接口，如下：

```java
//获取锁,会阻塞一直到成功
void lock();

//与lock不同的是可以响应中断，如果被其他线程中断，则抛出InterruptedException
void lockInterruptibly() throws InterruptedException;

//尝试获取锁，立即返回，不阻塞。成功返回true,否则返回false
boolean tryLock();

boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

//释放锁
void unlock();

//新建一个条件
Condition newCondition();
```

支持以非阻塞方式获取锁，可以响应中断，可以限时，相比synchronized更灵活。

主要实现类为可重入锁[ReentrantLock](ReentrantLock.md)